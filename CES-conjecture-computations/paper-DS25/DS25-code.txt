//=========================================================================

// Conjecture CES

// Some computations with modular symbols for X_1(p) for p=11,13,...,113
// based on [Parent 2000]; see also William Stein's book [Stein 207], Chapter 8.

start_time := Cputime();

p := ;

if not assigned p then
  p := 29;
end if;
F := GF(p); p2 := ExactQuotient(p-1, 2);

printf "\n=============================================================================\n";
printf "We show that J_1(%o)(Q)_tors is generated by differences of rational cusps.\n", p;
printf "=============================================================================\n\n";

printf "Setting up modular symbols...\n\n";

RG := [<F!0, F!b> : b in [1..p2]] cat [<F!a, b> : b in F, a in [1..p2]];
ZRG := FreeAbelianGroup(#RG);

function index(pair) // index in RG
  a := Integers()!pair[1];
  if a eq 0 then
    b := Integers()!pair[2];
    if b gt p2 then
      pair := <F!0, -F!b>;
    end if;
  else
    if a gt p2 then
      pair := <-pair[1], -pair[2]>;
    end if;
  end if;
  return Position(RG, pair);
end function;

sigma_perm := [index(<-pair[2], pair[1]>) : pair in RG];
tau_perm := [index(<pair[2], -pair[1]-pair[2]>) : pair in RG];

sigma_ZRG := hom<ZRG -> ZRG | [ZRG.sigma_perm[i] - ZRG.i : i in [1..#RG]]>;
tau_ZRG := hom<ZRG -> ZRG | [ZRG.tau_perm[i] - ZRG.i : i in [1..#RG]]>;
fix_sigma := Kernel(sigma_ZRG);
fix_tau := Kernel(tau_ZRG);

// Set up the boundary map Z[R_G] --> Z[cusps]
Zcusps := FreeAbelianGroup(p-1);
  // ordering of the cusps: (1/1, 1/2, ..., 1/p2, 1/p, 2/p, ..., p2/p)
  // note that 1/1 ~ 0 and 1/p ~ oo
norm := func<x | (xx gt p2 select p-xx else xx) where xx := Integers()!x>; // F mod +-1
cusp1 := func<pair | pair[2] eq 0 select p2 + norm(pair[1]^-1) else norm(pair[2])>;
cusp2 := func<pair | cusp1(<pair[2], pair[1]>)>;
// delta is the boundary map
delta := hom<ZRG -> Zcusps | [Zcusps.cusp1(pair) - Zcusps.cusp2(pair) : pair in RG]>;
ker_delta := Kernel(delta);
// The relative integral homology H_1(X_1(p)(C), cusps, Z):
H1_cusp, torelhom := quo<ZRG | fix_sigma + fix_tau>;
// The integral homology H_1(X_1(p)(X), Z):
H1_X1p_Z, tointhom := quo<ker_delta | fix_sigma + fix_tau>;
// The inclusion map of the latter into the former:
incl := hom<H1_X1p_Z -> H1_cusp | [torelhom(g @@ tointhom) : g in OrderedGenerators(H1_X1p_Z)]>;

printf "The relative homology H_1(X_1(%o)(C), cusps, Z) has rank %o\n", p, #Invariants(H1_cusp);
printf "The homology H_1(X_1(%o)(C), Z) has rank %o\n\n", p, #Invariants(H1_X1p_Z);

// Set up diamond, Hecke, star operators.

// Right action of an integral matrix that is invertible mod p
// on the Manin symbols:
act := func<pair, mat | RG[index(<pair[1]*mat[1,1]+pair[2]*mat[2,1],
                                  pair[1]*mat[1,2]+pair[2]*mat[2,2]>)]>;

// Get induced operator on the homology from operator on Z[R_G]
induced_op_relhom := func<op | hom<H1_cusp -> H1_cusp
                                    | [torelhom(op(g @@ torelhom))
                                        : g in OrderedGenerators(H1_cusp)]>>;
induced_op_inthom := func<op | hom<H1_X1p_Z -> H1_X1p_Z
                                    | [tointhom(op(g @@ tointhom))
                                        : g in OrderedGenerators(H1_X1p_Z)]>>;
// extract the matrix of an endomorphism on the homology
matrix_inthom := func<h | Matrix([Eltseq(h(g)) : g in OrderedGenerators(H1_X1p_Z)])>;
matrix_relhom := func<h | Matrix([Eltseq(h(g)) : g in OrderedGenerators(H1_cusp)])>;

// diamond operator on Z[R_G]
diamond_ZRG := func<n | hom<ZRG -> ZRG | [ZRG.index(<n*pair[1], n*pair[2]>) : pair in RG]>>;
// Hecke operator on Z[R_G] for prime index /= p
hecke_ZRG := func<q | hom<ZRG -> ZRG | [&+[ZRG.index(act(pair, m)) : m in mats]
                                           : pair in RG]>
                      where mats := [Matrix(2, 2, m) : m in HeilbronnMerel(q)]>;
// star involution
// Note that this corresponds to complex conjugation on X_1(p)(C);
// it is the negative of the version in Stein's book.
star_ZRG := hom<ZRG -> ZRG | [ZRG.index(<-pair[1], pair[2]>) : pair in RG]>;

printf "Setting up Hecke and diamond operators...\n\n";

// Set up some of the operators on Z[R_G].
primes := PrimesInInterval(3, 7);
time hecke_ops_ZRG := [hecke_ZRG(q) : q in primes];
diamond_ops_ZRG := [diamond_ZRG(q) : q in primes];

// Determine Eisenstein sublattice of the relative homology.
// If T is a Hecke operator on the relative homology and its restriction
// to the integral homology has characteristic polynomial f, then f(T)
// maps the relative homology into the Eisenstein sublattice.
// We know that this sublattice has rank #cusps - 1 = p - 2,
// so it suffices to find one T = T_q such that the image of T has the
// correct rank. See Table 4.6 for the specific T_q to use
// for each prime. In our case, the largest q encountered so far is 17.
T3_relhom := induced_op_relhom(hecke_ops_ZRG[1]);
T3_relhom_mat := matrix_relhom(T3_relhom);
T3_inthom := induced_op_inthom(hecke_ops_ZRG[1]);
cpT3_inthom := CharacteristicPolynomial(matrix_inthom(T3_inthom));
op_Eis := Evaluate(cpT3_inthom, T3_relhom_mat);
assert Rank(op_Eis) eq p-2; // check that rank is correct
// We get the Eisenstein sublattice by saturating the image of op_Eis.
LEis := PureLattice(Lattice(op_Eis));
// Now we need the basis we use for the integral homology inside
// the relative homology.
basS := [Vector(Eltseq(incl(g))) : g in OrderedGenerators(H1_X1p_Z)];

// Now we determine the image of the integral relative homology
// inside the rational homology. Its quotient by the integral homology
// is (isomorphic to) the cuspidal subgroup of J_1(p)_tors.

// We get the matrix that maps the integral relative homology
// into the rational homology by stacking the basis of the integral
// homology onto the basis of the Eisenstein sublattice, inverting
// the resulting matrix and removing the last p-2 columns.
basESmat := Matrix(basS cat Basis(LEis));
basESmati := ChangeRing(basESmat, Rationals())^-1;
projmat := Submatrix(basESmati, 1, 1, Nrows(basESmati), #basS);

// The image of the relative homology in the integral homology
// (as a lattice in Q^(2 g(X_1(p)))):
L0 := Lattice(IdentityMatrix(Integers(), #basS)); // integral lattice = integral homology
Lcusp := Lattice(projmat) + L0;
// The cuspidal subgroup of J_1(p):
Qcusp, toQcusp := quo<Lcusp | L0>;
printf "\nThe cuspidal torsion subgroup of J_1(%o)\n", p;
printf "has invariants %o\n\n", Invariants(Qcusp);

// Get the induced operators on the integral homology ...
hecke_ops := [induced_op_inthom(T) : T in hecke_ops_ZRG];
diamond_ops := [induced_op_inthom(d) : d in diamond_ops_ZRG];
star_op := induced_op_inthom(star_ZRG);

// ... and their matrices.
hecke_mats := [matrix_inthom(T) : T in hecke_ops];
diamond_mats := [matrix_inthom(d) : d in diamond_ops];
star_mat := matrix_inthom(star_op);
star_mat_Q := ChangeRing(star_mat, Rationals());
id_mat := Parent(star_mat)!1;

// We know that for 2 < q /= p prime, the operator
//  T_q - q - <q>
// annihilates rational torsion; the same is true of star - 1.
// We use this to find an upper bound on the rational torsion subgroup.
ann_ops := [hecke_mats[j] - diamond_mats[j] - primes[j]*id_mat : j in [1..#primes]];
ann_ops_Q := [ChangeRing(mat, Rationals()) : mat in ann_ops];
L1 := &meet[Lattice(m^-1) : m in ann_ops_Q];
// Get action of star on L1/L0 and pull back fixed points.
Q1, toQ1 := quo<L1 | L0>;
star_minus_1_on_Q1 := hom<Q1 -> Q1 | [toQ1((g @@ toQ1)*star_mat_Q) - g
                                       : g in OrderedGenerators(Q1)]>;
Q1fix := Kernel(star_minus_1_on_Q1);
L := L0 + Lattice(Matrix([g @@ toQ1 : g in Generators(Q1fix)]));
// Now L/L0 is our upper bound on J_1(p)(Q)_tors.
Q, toQ := quo<L | L0>;
printf "The group bounding the rational torsion subgroup of J_1(%o)\n", p;
printf "has invariants %o\n\n", Invariants(Q);

// We check that L/L0 is contained in the cuspidal torsion subgroup:
assert L subset Lcusp;
printf "This group is contained in the cuspidal subgroup.\n\n";

// It remains to verify that the rational (i.e., Galois invariant) part
// of the cuspidal group is generated by differences of rational cusps.

// The rational cusps are the cusps j/p (that map to infinity on X_0(p)).
// The other cusps 1/j are permuted cyclically by Galois.
// Since the Galois action commutes with the diamond operators,
// the action is the same as that of the diamond operators;
// in particular, it is generated by the action of <2> (for p = 29).
r := PrimitiveRoot(p);
printf "%o is a primitive root mod %o\n\n", r, p;
assert Order(GF(p)!r) eq p-1; // 2 is a primitive root
// We take the rational cusp oo (number p2+1) as base-point.
// Images of differences  cusp - oo  in the rational homology:
cusp_diffs := [Vector(Rationals(),
                      Eltseq(torelhom((Zcusps.j - Zcusps.(p2+1)) @@ delta)))*projmat
                : j in [1..p-1]];
Zcusps_to_Qcusp := hom<Zcusps -> Qcusp | [toQcusp(Lcusp!cd) : cd in cusp_diffs]>;

// The Galois action on the cusps as a permutation.
// The first p2 cusps are permuted cyclically, the last p2 are fixed.
Gal_action := [norm(r*F!j) : j in [1..p2]] cat [p2+j : j in [1..p2]];
Gal_on_Zcusps := hom<Zcusps -> Zcusps | [Zcusps.j : j in Gal_action]>;
// The induced action on the cuspidal subgroup, minus the identity ...
Gal_minus_1_on_Qcusp
  := hom<Qcusp -> Qcusp | [Zcusps_to_Qcusp(Gal_on_Zcusps(g @@ Zcusps_to_Qcusp)) - g
                            : g in OrderedGenerators(Qcusp)]>;
// ... and the fixed subgroup.
Qcusp_fix := Kernel(Gal_minus_1_on_Qcusp);
printf "The rational cuspidal subgroup has invariants %o\n", Invariants(Qcusp_fix);
// Now the subgroup coming from rational cusps.
Qcusp_rat := sub<Qcusp | [Zcusps_to_Qcusp(Zcusps.j) : j in [p2+1..p-1]]>;
printf "The subgroup coming from rational cusps has invariants %o\n\n", Invariants(Qcusp_rat);
// Check they are equal.
assert Qcusp_fix eq Qcusp_rat;
printf "Both groups are equal!\n\n";


// Stop timer
end_time := Cputime();

// Print the execution time
execution_time := end_time - start_time;
print "Execution time:", execution_time, "seconds";